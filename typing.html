<html>
  <head>
    <style>
#gamediv{
  width: 640px;
  margin: 20px auto;
}
#gamecanvas{
  background-color:#eee;
}
    </style>
  </head>
  <body>
    <div id="gamediv">
      <canvas id="gamecanvas" width="640" height="480"></canvas>
    </div>
    <div>fps: <span id="fps"></span></div>
  </body>
  <script>


function CreateEngine(canvasId){
  var engine = {};
  engine.canvas = document.getElementById(canvasId);
  engine.ctx = engine.canvas.getContext("2d");
  engine.screenWidth = engine.canvas.width;
  engine.screenHeight = engine.canvas.height;
  engine.lastframe = 0;
  engine.spirits = [];
  engine.controlKeys = {};

  engine.addSpirit = function (zOdr, spirit) {
    this.spirits.push({zOrder: zOdr, spirit:spirit});
    spirit.setCtx(this.ctx);
    // sort spirits by z-order.
  };

  engine.findSpirit = function(id){
    for(i=0; i<this.spirits.length; i++){
      if(this.spirits[i].spirit.id == id) {
        return this.spirits[i].spirit;
      }
    }
  };

  engine.clearDeadSpirits = function(){
    for(i=this.spirits.length-1; i>=0; i--){
      if (this.spirits[i].spirit.deleted 
          || (typeof this.spirits[i].spirit.hp !== 'undefined' && this.spirits[i].spirit.hp < 0)) {
        this.spirits.splice(i,1);
      }
    }
  };

  engine.start = function (tframe) {
    window.requestAnimationFrame(engine.start);

    engine.ctx.clearRect(0, 0, engine.canvas.width, engine.canvas.height);

    engine.spirits.forEach(function(e){
      // check the spirit if it is out of the screen.
      if (e.spirit.x < -(engine.canvas.width)
          || e.spirit.x > 2 * engine.canvas.width
          || e.spirit.y < -(engine.canvas.height)
          || e.spirit.y > 2 * engine.canvas.height) {
        e.spirit.deleted = true;
      }

      e.spirit.draw();
    });

    engine.clearDeadSpirits();

    // debug info
    document.getElementById('fps').innerText = 1000 / (tframe-engine.lastframe).toString();
    engine.lastframe = tframe
  };

  engine.addContorlButton = function (keyCode, callback){
    engine.controlKeys[keyCode] = callback;
  }

  var keyControl = function (e) {
    if(typeof engine.controlKeys[e.keyCode] !== 'undefined'){
      engine.controlKeys[e.keyCode]();
    }
  }

  document.addEventListener("keydown", keyControl, false);

  return engine;
}

function CreateSpirit(){
  var that = {};
  that.id = '';
  that.deleted = false;
  that.x = 0;
  that.y = 0;
  that.ctx = null;
  that.setCtx = function(ctx){
    that.ctx = ctx;
  };
  return that;
}

function CreateBullet(){
  var that = CreateSpirit();
  that.speed = 0;
  that.angle = 0;
  that.draw = function(){
    that.ctx.beginPath();
    that.x = that.x + Math.cos(that.angle) * that.speed;
    that.y = that.y + Math.sin(that.angle) * that.speed;
    that.ctx.arc(that.x, that.y, 3, 0, Math.PI * 2);
    that.ctx.fillStyle = "#dd9500";
    that.ctx.fill();
    that.ctx.closePath();
  };
  return that;
}

function CreateEnemy(id) {
  var that = CreateSpirit();
  that.speed = 0.0;
  that.t = 0;
  that.destX = 0;
  that.destY = 0;
  that.startX = 0;
  that.startY = 0;
  that.id = id;
  that.draw = function(){

    var t = that.t;
    that.ctx.beginPath();
    that.x = (1-t)*(1-t)*that.startX + 2*t*(1-t)*engine.screenWidth/2 + t*t*that.destX;
    that.y = (1-t)*(1-t)*that.startY + 2*t*(1-t)*engine.screenHeight/2 + t*t*that.destY;
    that.ctx.rect(that.x - 10, that.y - 10, 20, 20);
    that.ctx.fillStyle = "#00dd95";
    that.ctx.fill();
    that.ctx.closePath();

    that.ctx.font = "20px serif";
    that.ctx.fillStyle = "#000";
    that.ctx.fillText(id, that.x - 2, that.y+2);

    that.t += that.speed;

    if(that.t > 1) {
      that.deleted = true;
      return;
    }

  };

  return that;
}

var engine = CreateEngine('gamecanvas');

var hq = CreateSpirit();
hq.x = engine.screenWidth / 2;
hq.y = engine.screenHeight / 2;
hq.hp = 100;
hq.draw = function () {
  hq.ctx.beginPath();
  hq.ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
  hq.ctx.fillStyle = "#0095DD";
  hq.ctx.fill();
  hq.ctx.closePath();
};

hq.fire = function(e) {
  if(typeof e === 'undefined' || e == null) return;

  var bullet = CreateBullet();
  bullet.speed = 5;

  var t = e.t + e.speed * 20;
  var tgtX = (1-t)*(1-t)*e.startX + 2*t*(1-t)*engine.screenWidth/2 + t*t*e.destX;
  var tgtY = (1-t)*(1-t)*e.startY + 2*t*(1-t)*engine.screenHeight/2 + t*t*e.destY;

  bullet.angle = Math.atan((tgtY - engine.screenHeight / 2) / (tgtX - engine.screenWidth / 2));

  if(tgtY < engine.screenHeight / 2 && tgtX < engine.screenWidth / 2){
    bullet.angle += Math.PI;
  }
  else if(tgtY > engine.screenHeight / 2 && tgtX < engine.screenWidth / 2){
    bullet.angle -= Math.PI;
  }
  bullet.x = hq.x;
  bullet.y = hq.y;
  engine.addSpirit(2, bullet);
};

engine.addSpirit(1, hq);

engine.addContorlButton(65, function(){
  hq.fire(engine.findSpirit('a'));
});

engine.addContorlButton(83, function(){
  hq.fire(engine.findSpirit('s'));
});

engine.addContorlButton(68, function(){
  hq.fire(engine.findSpirit('d'));
});

engine.addContorlButton(70, function(){
  hq.fire(engine.findSpirit('f'));
});

engine.start();

var getBtn = function(){
  var btn = ['a','s','d','f'];
  var nin1 = 4;

  return function(){

    var retval;

    if(nin1 == 1) {
      nin1 = 4;
      retval = btn[0];
      btn[0] = 'a';
      btn[1] = 's';
      btn[2] = 'd';
      btn[3] = 'f';
      return retval;
    }

    // nin1 > 1, idx is a random in [1..nin1)
    var idx = Math.floor(Math.random() * nin1);
    retval = btn[idx];
    if (idx < nin1 - 1) {
      btn[idx] = btn[nin1-1];
    }

    nin1--;
    return retval;
  };
}();

function addEnemy(){
  var e = CreateEnemy(getBtn());

  e.angle = Math.random() * Math.PI * 2;
  e.speed = 0.003;

  var w = engine.screenWidth / 2;
  var h = engine.screenHeight / 2;

  var r = Math.sqrt(w * w + h * h);

  e.startX = w + r * Math.cos(e.angle);
  e.startY = h + r * Math.sin(e.angle);

  e.destX = w + r * Math.cos(e.angle + Math.PI * 3 / 4);
  e.destY = h + r * Math.sin(e.angle + Math.PI * 3 / 4);

  engine.addSpirit(1, e);
}

setInterval(addEnemy, 2500);

  </script>
</html>
